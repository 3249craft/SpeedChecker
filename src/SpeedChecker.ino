#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 32
#define OLED_RESET -1   // No reset pin
#define OLED_ADDR 0x3C  // Most common

Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

const char firmware_version[] = "SpeedChkr v0.0.1b";
const unsigned long splash_duration_ms = 2500;

const uint8_t logo_v1[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x9F, 0x98,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFC,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xFF, 0xFC,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xF0, 0xF8,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78,
  0x07, 0xF0, 0x0F, 0xF0, 0x7F, 0xC0, 0x1E, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x38,
  0x1F, 0xFC, 0x1F, 0xF8, 0x7F, 0xE0, 0x1E, 0x1F, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x70, 0x1E,
  0x3C, 0x1E, 0x1C, 0x3C, 0xF0, 0xE0, 0x3E, 0x3C, 0x38, 0x00, 0x00, 0x00, 0x00, 0x70, 0x70, 0x1F,
  0x30, 0x07, 0x18, 0x1C, 0xE0, 0x60, 0x7E, 0x38, 0x18, 0x00, 0x00, 0x00, 0x00, 0x60, 0x70, 0x1F,
  0x71, 0xD3, 0x00, 0x1C, 0x00, 0x60, 0xF6, 0x38, 0x1C, 0x3F, 0x0F, 0xC7, 0xF1, 0xFD, 0xFE, 0x1F,
  0x67, 0xF3, 0x00, 0x1C, 0x00, 0xE1, 0xE6, 0x38, 0x18, 0x7F, 0x1F, 0xC7, 0xF9, 0xFD, 0xFE, 0x3C,
  0xE6, 0x73, 0x81, 0xF8, 0x01, 0xE1, 0xC6, 0x38, 0x1C, 0xE0, 0x1C, 0x00, 0x38, 0xE0, 0x70, 0x78,
  0xEE, 0x33, 0x83, 0xF8, 0x1F, 0xC3, 0x86, 0x1F, 0xFC, 0xE0, 0x18, 0x00, 0x38, 0x60, 0x70, 0xF8,
  0xCE, 0x33, 0x81, 0xFC, 0x7F, 0x87, 0x06, 0x1F, 0xFC, 0xE0, 0x18, 0x07, 0xF8, 0x60, 0x70, 0xFC,
  0xE6, 0x3B, 0x00, 0x1C, 0xF8, 0x07, 0x0F, 0x07, 0xDC, 0xE0, 0x18, 0x0F, 0xF8, 0x60, 0x70, 0xFC,
  0x67, 0xFF, 0x00, 0x1C, 0xE0, 0x07, 0xFF, 0x80, 0x1C, 0xE0, 0x18, 0x1C, 0x38, 0x60, 0x70, 0x98,
  0x63, 0xDE, 0x00, 0x1C, 0xE0, 0x07, 0xFF, 0x80, 0x1C, 0xE0, 0x18, 0x1C, 0x38, 0x60, 0x70, 0x00,
  0x30, 0x00, 0x18, 0x1C, 0xE0, 0x00, 0x06, 0x18, 0x38, 0xE0, 0x18, 0x1C, 0x38, 0x60, 0x70, 0x00,
  0x3C, 0x00, 0x1F, 0xFC, 0xFF, 0xE0, 0x06, 0x1F, 0xF8, 0xFF, 0x18, 0x1F, 0xF8, 0x60, 0x7E, 0x00,
  0x1F, 0xF8, 0x1F, 0xF8, 0xFF, 0xE0, 0x06, 0x1F, 0xF8, 0x7F, 0x18, 0x0F, 0xF8, 0x60, 0x3E, 0x00,
  0x07, 0xF0, 0x03, 0xC0, 0x00, 0x00, 0x00, 0x07, 0xE0, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// QRE1113 digital signal input (interrupt-capable pin).
// Using D1 (TXO) on ATmega32U4 (Leonardo/Pro Micro).
const uint8_t sensor_pin = 1;
const uint8_t spokes_per_rev = 3;
const uint8_t edges_per_spoke = 1;
const float wheel_diameter_mm = 19.0f;
const float wheel_diameter_m = wheel_diameter_mm / 1000.0f;
const float distance_per_pulse_m =
    (PI * wheel_diameter_m) / (spokes_per_rev * edges_per_spoke);
const float max_speed_kmh = 99.0f;
const unsigned long speed_update_ms = 500;
const unsigned long min_pulse_interval_us = 120;

volatile unsigned long pulse_count = 0;
volatile unsigned long last_pulse_us = 0;
volatile unsigned long last_interval_us = 0;
volatile unsigned long min_interval_us = 0xFFFFFFFF;

float current_speed_kmh = 0.0f;
float top_speed_kmh = 0.0f;
unsigned long last_display_ms = 0;
bool signal_active = false;
unsigned long last_min_interval_us = 0;
unsigned long last_pps = 0;

void pulse_isr() {
  unsigned long now_us = micros();
  if (min_pulse_interval_us > 0 &&
      last_pulse_us != 0 &&
      (now_us - last_pulse_us) < min_pulse_interval_us) {
    return;
  }
  if (last_pulse_us != 0) {
    unsigned long interval_us = now_us - last_pulse_us;
    last_interval_us = interval_us;
    if (interval_us < min_interval_us) {
      min_interval_us = interval_us;
    }
  }
  last_pulse_us = now_us;
  pulse_count++;
}

void draw_speed() {
  char buf[8];
  char min_buf[12];
  char pps_buf[16];

  display.clearDisplay();
  display.setTextColor(SSD1306_WHITE);

  display.setTextSize(2);
  display.setCursor(0, 0);
  dtostrf(current_speed_kmh, 4, 1, buf);
  display.print(buf);
  display.print("km/h");
  display.setTextSize(1);
  display.setCursor(96, 0);
  display.print(signal_active ? "SIG" : "NO");

  display.setTextSize(1);
  display.setCursor(0, 20);
  snprintf(pps_buf, sizeof(pps_buf), "PPS %lu", last_pps);
  display.print(pps_buf);
  display.print(" MIN ");
  snprintf(min_buf, sizeof(min_buf), "%luus", last_min_interval_us);
  display.print(min_buf);

  display.display();
}

void show_splash() {
  unsigned long start = millis();
  uint16_t progress = 0;
  uint8_t prng = (uint8_t)(start | 1);

  while (progress < SCREEN_WIDTH) {
    unsigned long elapsed = millis() - start;
    uint16_t target = (uint32_t)elapsed * SCREEN_WIDTH / splash_duration_ms;
    prng ^= prng << 3;
    prng ^= prng >> 5;
    prng ^= prng << 1;
    int8_t jitter = (int8_t)(prng % 5) - 2;
    int16_t next_progress = (int16_t)target + jitter;
    if (next_progress < (int16_t)progress) {
      next_progress = progress;
    }
    if (next_progress > SCREEN_WIDTH) {
      next_progress = SCREEN_WIDTH;
    }
    progress = (uint16_t)next_progress;

    display.clearDisplay();
    display.drawBitmap(0, 0, logo_v1, SCREEN_WIDTH, SCREEN_HEIGHT, SSD1306_WHITE);
    display.setTextSize(1);
    display.setTextColor(SSD1306_WHITE);
    display.setCursor(0, 0);
    display.print(firmware_version);
    display.fillRect(0, SCREEN_HEIGHT - 3, progress, 3, SSD1306_WHITE);
    display.display();

    prng ^= prng << 2;
    prng ^= prng >> 7;
    prng ^= prng << 3;
    uint8_t delay_ms = 30 + (prng % 120);
    delay(delay_ms);
  }
}

void setup() {
  if (!display.begin(SSD1306_SWITCHCAPVCC, OLED_ADDR)) {
    while (true); // OLED not found
  }

  display.clearDisplay();
  show_splash();

  pinMode(sensor_pin, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(sensor_pin), pulse_isr, RISING);
}

void loop() {
  static unsigned long last_update_ms = 0;
  unsigned long now_ms = millis();
  unsigned long now_us = micros();

  if (now_ms - last_update_ms >= speed_update_ms) {
    unsigned long count_copy = 0;
    unsigned long last_pulse_copy = 0;
    unsigned long interval_copy = 0;
    unsigned long min_interval_copy = 0;
    float window_sec = (now_ms - last_update_ms) / 1000.0f;

    noInterrupts();
    count_copy = pulse_count;
    pulse_count = 0;
    last_pulse_copy = last_pulse_us;
    interval_copy = last_interval_us;
    min_interval_copy = min_interval_us;
    min_interval_us = 0xFFFFFFFF;
    interrupts();

    if (window_sec > 0.0f) {
      last_pps = (unsigned long)(count_copy / window_sec);
    }

    if (count_copy >= 2 && window_sec > 0.0f) {
      float speed_mps = (count_copy * distance_per_pulse_m) / window_sec;
      current_speed_kmh = speed_mps * 3.6f;
      if (current_speed_kmh > top_speed_kmh) {
        top_speed_kmh = current_speed_kmh;
      }
    } else if (interval_copy > 0) {
      float seconds = interval_copy / 1000000.0f;
      float speed_mps = distance_per_pulse_m / seconds;
      current_speed_kmh = speed_mps * 3.6f;
      if (current_speed_kmh > top_speed_kmh) {
        top_speed_kmh = current_speed_kmh;
      }
    } else {
      current_speed_kmh = 0.0f;
    }
    if (current_speed_kmh > max_speed_kmh) {
      current_speed_kmh = max_speed_kmh;
    }

    signal_active = (count_copy > 0) ||
                    ((last_pulse_copy != 0) && ((now_us - last_pulse_copy) < (speed_update_ms * 2000UL)));
    if (!signal_active) {
      current_speed_kmh = 0.0f;
    }
    if (min_interval_copy != 0xFFFFFFFF) {
      last_min_interval_us = min_interval_copy;
    }
    last_update_ms = now_ms;
    last_display_ms = now_ms;
    draw_speed();
  }
}
